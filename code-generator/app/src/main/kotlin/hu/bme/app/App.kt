/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package hu.bme.app

import app.model.ResolutionTree
import java.io.File
import java.util.*

const val maxPredicateSize = 15;

fun main() {

    val prologCode = """
% policy.pl 
% input.pl
monthly_consumption(1,2001).
monthly_consumption(2,2001).
monthly_consumption(3,2001).
monthly_consumption(4,2001).
monthly_consumption(5,2001).
monthly_consumption(6,2001).
monthly_consumption(7,2000).
monthly_consumption(8,2000).
monthly_consumption(9,2000).
monthly_consumption(10,2000).
monthly_consumption(11,2000).
monthly_consumption(12,2000).

currentConsumption(1400).

currentPrice(747,'HUF').

inputPayment(931220).
% matrix.pl
% Tresholds
rolling_treshold('low', 0).
rolling_treshold('mid', 3000).
rolling_treshold('high',7000).

savings_treshold('low',250).
savings_treshold('mid',500).
savings_treshold('high',1000).

% Supportmatrix
% support_matrix(Rolling_class, savings_class, type, value)
support_matrix('low', 'low', 'nominal', 500).
support_matrix('low', 'mid', 'percent', 10).
support_matrix('low', 'high', 'nominal', 500).
support_matrix('mid', 'low', 'nominal', 500).
support_matrix('mid', 'mid', 'nominal', 500).
support_matrix('mid', 'high', 'nominal', 500).
support_matrix('high', 'low', 'nominal', 500).
support_matrix('high', 'mid', 'nominal', 500).
support_matrix('high', 'high', 'nominal', 500).

% Social Suports: social_suport(credType,type,value)
social_suport('ChangedWorkcapacityCredential','nominal',10000).

% Flow: 
% 1. sum individual past consumptions
% 2. calculate rolling consumption
% 3. classify using rolling consumpiton
% 4. classify using currently saved amount compared to rollingconsumption
% 5. apply savings based support to base payement
% 6. apply social credential based support 

% === 1. Aggregate past consumptions ===

% monthlyConsumptions(MonthlyConsumptions) :- findall((Amount), monthly_consumption(_,Amount), MonthlyConsumptions).
% monthlyConsumptions(MonthlyConsumptions) :- MonthlyConsumptions = [(1,2001),(2,2001),(3,2001),(4,2001),(5,2001),(6,2001),(7,2000),(8,2000),(9,2000),(10,2000),(11,2000),(12,2000)].
monthlyConsumptions(MonthlyConsumptions) :- MonthlyConsumptions = [2001,2001,2001,2001,2001,2001,2000,2000,2000,2000,2000,2000].

sumOfMonthlyConsumptions([Amount|Tail],Sum) :- sumOfMonthlyConsumptions(Tail,SumOfTail), Sum is SumOfTail + Amount.
sumOfMonthlyConsumptions([],0).

% === 2. Calculate rolling consumption ===
rollingConsumption(Sum,Result):- 
    Result is Sum / 12.

% === 3. classify using rolling consumption ===   
consumptionClass(RollingConsumption,Class):-
    rolling_treshold('high',Treshold),
    RollingConsumption > Treshold,
    Class = 'high';
    rolling_treshold('mid',Treshold),
    RollingConsumption > Treshold,
    Class = 'mid';
    Class = 'low'.

% === 4. classify using savings ===
savingsClass(RollingConsumption,Consumption,Class):-
    savings_treshold('high',Treshold),
    CurrentSaving is RollingConsumption - Consumption,
    CurrentSaving > Treshold,
    Class = 'high';
    savings_treshold('mid',Treshold),
    CurrentSaving is RollingConsumption - Consumption,
    CurrentSaving > Treshold,
    Class = 'mid';
    savings_treshold('low',Treshold),
    CurrentSaving is RollingConsumption - Consumption,
    CurrentSaving > Treshold,
    Class = 'low';
    Class = 'none'.

% === 5. Apply savings based support ===
priceBase(PriceBase):-
    currentConsumption(Amount),
    currentPrice(Price,'HUF'),
    PriceBase is Price * Amount.

applySupport(Input, 'nominal', Value, Output):-
    Output is Input - Value.
applySupport(Input, 'percent', Value, Output):-
    AmountToBeSubtracted is Input * Value / 100,
    Output is Input - AmountToBeSubtracted.

applySavingsSupport(Input, SavingsClass, RollingClass, Output):-
    support_matrix(RollingClass, SavingsClass, Type, Value),
    applySupport(Input, Type, Value, Output).

% === 6. Apply social standing based support ===
socialCreds(Creds):- Creds = [('ChangedWorkcapacityCredential','nominal',10000)].
% socialCreds(Creds) :- findall((CredType,SupportType,SupportValue), social_suport(CredType,SupportType,SupportValue), Creds).

applySocialSupports(Input,[(_,SupportType,SupportValue)|CredsTail],Result):-
    applySupport(Input, SupportType, SupportValue,Output),
    applySocialSupports(Output,CredsTail,Result).
applySocialSupports(Input,[], Input).

endPrice(Price):-
    monthlyConsumptions(MonthlyConsumptions),
    sumOfMonthlyConsumptions(MonthlyConsumptions,Sum),
    rollingConsumption(Sum,RollingConsumption),
    currentConsumption(Consumption),
    consumptionClass(RollingConsumption,ConsumptionClass),
    savingsClass(RollingConsumption,Consumption,SavingsClass),
    priceBase(PriceBase),
    applySavingsSupport(PriceBase, SavingsClass, ConsumptionClass, PriceAfterSavings),
    socialCreds(Creds),
    applySocialSupports(PriceAfterSavings,Creds,Price).

inputPriceOk:-
    endPrice(Price),
    inputPayment(Price).

writeSteps:-
    monthlyConsumptions(MonthlyConsumptions),
    sumOfMonthlyConsumptions(MonthlyConsumptions,Sum),
    rollingConsumption(Sum,RollingConsumption),
    currentConsumption(Consumption),
    consumptionClass(RollingConsumption,ConsumptionClass),
    savingsClass(RollingConsumption,Consumption,SavingsClass),
    priceBase(PriceBase),
    applySavingsSupport(PriceBase, SavingsClass, ConsumptionClass, PriceAfterSavings),
    socialCreds(Creds),
    applySocialSupports(PriceAfterSavings,Creds,Price).
    """.trimIndent()

    val clauses = Parser.parseProlog(prologCode)
    //clauses.forEach { println(it) }
    val mapping = createMapping(clauses)

    mapping.forEach { (name, index) ->
        println("$name: $index")
    }
    println("Knowledge base:")
    clauses.filter { it.body.isEmpty() }.forEach { clause ->
        println(clause.head.encode(mapping))
    }
    val knowledgeBase = clauses.filter { it.body.isEmpty() }
    println("Rules:")
    val rules = clauses.filter { it.body.isNotEmpty() }.groupBy { it.head.name }
    rules.forEach { (name, rules) ->
        println("$name:")
        rules.forEach { rule ->
            println(
                "  ${
                    rule.body.joinToString(" & ") {
                        it.encode(mapping).toString()
                    }
                } => ${rule.head.encode(mapping)}"
            )
        }
    }



    val bucketVariables = findArrayPredicateVariables(rules)
    val maxBucketElementSize = findArrayTermMaxSize(rules)
    println("Bucket max size: $maxBucketElementSize")

    val generated_rule_code = StringBuilder()
    val maxPerdicateLength = rules.maxOf { it.value[0].body.maxOf { it.terms.size } } + 1
    rules.forEach { (name, rule_clauses) ->
        // Find matching terms in the body and the head of the rules
        // For example, if we have the following rule:
        // ancestor(X, Y) :- parent(X, Y).
        // Then the matching terms are:
        // X: goal first argument and first rule first argument
        // Y: goal second argument and first rule second argument
        // We need to find the matching terms because we need to unify them

        // Find matching terms in the body of the rules
        val constraints = mutableListOf<String>()
        rule_clauses.forEach { rule ->
            // Store the positions of the matching terms in the body and the head of the rule
            // It's a list of pairs, where the first element is the position in the body or the head (the head is the 0th index)
            // and the second element is the index of the argument in the predicate
            val headPositions = mutableMapOf<String, MutableList<Int>>()
            val termPositions = mutableMapOf<String, MutableList<Pair<Int, Int>>>()
            rule.head.terms.forEachIndexed { headIndex, term ->
                if (term is Variable) {
                    if (!headPositions.containsKey(term.name)) {
                        headPositions[term.name] = mutableListOf()
                    }
                    headPositions[term.name]!!.add(headIndex)
                }
            }
            rule.body.forEachIndexed { bodyIndex, predicate ->
                predicate.terms.forEachIndexed { termIndex, term ->
                    if (term is Variable) {
                        if (!termPositions.containsKey(term.name)) {
                            termPositions[term.name] = mutableListOf()
                        }
                        termPositions[term.name]!!.add(
                            Pair(
                                bodyIndex,
                                termIndex
                            )
                        )
                    }
                }
            }

            println(headPositions)
            println(termPositions)
            // From these positions, we can generate the circom code that check the unifications
            // For example, if we have the following rule:
            // ancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).
            // Then the generated code is:
            // assert( goal_args[1] == unification _body[1][1] && goal_args[2] == unification _body[1][2] && unification _body[0][2] == unification _body[1][1])
            // The first two terms are the matching terms in the head, the last term is the matching term in the body


            // Generate the code for the matching terms in the head
            val headUnification = termPositions.map { (name, positions) ->

                if (headPositions.isNotEmpty() && headPositions.containsKey(name)) {
                    val headPosition = headPositions[name]!!.toList()
                    buildList {
                        positions.forEach { position ->
                            headPosition.forEach { headPosition ->
                                //add("goal_args[${position.second + 1}] == unified_body[${position.first - 1}][${position.second + 1}]")
                                add("goal_args[${headPosition + 1}] == unified_body[${position.first}][${position.second + 1}]")
                            }
                        }

                    }.joinToString(" && ")

                } else {
                    ""
                }
            }.filter { it.isNotEmpty() }


            // Generate the code for the matching terms in the body
            val visited = mutableSetOf<Int>()
            val unifiedBodies = mutableListOf<String>()
            termPositions.forEach { variable, positions ->
                // Match the body positions with each other
                positions.forEach { bodyPosition ->
                    positions.forEach { otherBodyPosition ->
                        if (bodyPosition != otherBodyPosition && !visited.contains(bodyPosition.first) && !visited.contains(
                                otherBodyPosition.first
                            )
                        ) {
                            visited.add(bodyPosition.first)
                            unifiedBodies.add("unified_body[${bodyPosition.first}][${bodyPosition.second + 1}] == unified_body[${otherBodyPosition.first}][${otherBodyPosition.second + 1}]")
                        }
                    }
                }
            }
            val allConstraints = (headUnification + unifiedBodies)
            println(allConstraints.joinToString(" && "))
            constraints.add(allConstraints.joinToString(" && "))
        }

        val maxUniBody = rule_clauses.maxOf { it.body.size }
        generated_rule_code.appendLine(
            buildString {
                appendLine("template Goal${name.replaceFirstChar { if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString() }}() {")
                appendLine(
                    "\tsignal input unified_body[${maxUniBody}][$maxPerdicateLength];\n" +
                            "\tsignal input goal_args[$maxPerdicateLength];\n" +
                            "\tsignal output c;\n" +
                            "\tvar result = 0;\n" +
                            "\tvar none = 0;"
                )
                clauses.groupBy { it.head.name }.forEach { (name, _) ->
                    appendLine("\tvar ${name} = ${mapping[name]};")
                }
                appendLine("\n\tgoal_args[0] === ${name};")
                // Number of times we will name to check the knowledge base
                val knowledgeBaseUsage = rule_clauses.filter { rule ->
                    rule.body.size == knowledgeBase.groupBy { it.head.name }
                        .count { rule.body.map { it.name }.contains(it.key) }
                }.sumOf { rule -> rule.body.size }
                if (knowledgeBaseUsage == 1) {
                    appendLine("\tcomponent knowledge = KnowledgeChecker();")
                } else if (knowledgeBaseUsage > 1) {
                    appendLine("\tcomponent knowledge[$knowledgeBaseUsage];")
                    appendLine("\tfor (var i = 0; i < $knowledgeBaseUsage; i++) {")
                    appendLine("\t\tknowledge[i] = KnowledgeChecker();")
                    appendLine("\t}")
                }
                var knowledgeUsageCounter = 0
                var rule_prefix = "\t"
                rule_clauses.forEachIndexed { ind, rule ->
                    append("${rule_prefix}if ( ")
                    var prefix = ""
                    append(
                        buildList {
                            rule.body.forEachIndexed { index, predicate ->
                                add(
                                    "unified_body[${index}][0] == ${
                                        if (
                                            Parser.SPECIAL_TERMS.any {
                                                predicate.name.contains(it)
                                            }.not() &&
                                            Parser.OPERATORS.any {
                                                predicate.name.contains(it)
                                            }.not()
                                        )
                                            predicate.name else if (predicate.name == "=" && predicate.terms[1].name == "[]") mapping["true"] else mapping[predicate.name]
                                    }"
                                )

                            }
                            if(rule.body.size < rule_clauses.maxOf { it.body.size }){
                                var counter = rule.body.size
                                while(counter < rule_clauses.maxOf { it.body.size }){
                                    add("unified_body[${counter}][0] == 0")
                                    counter++
                                }
                            }
                        }.joinToString(" && ")
                    )
                    /*for (i in rule.body.size until rules.maxOf { it.value.size }) {
                        append("${prefix}unified_body[${i}][0] == none")
                    }*/
                    appendLine(" ) {")
                    if(rule.body.any { it.hasAritmetic() }){
                        appendLine(clauseGenerateArithmeticsCheck(rule))
                    }
                    val knowledgeBody =
                        knowledgeBase.groupBy { it.head.name }.count { rule.body.map { it.name }.contains(it.key) }
                    if (rule.body.size == knowledgeBody) {
                        if (knowledgeBaseUsage == 1) {
                            appendLine("\t\tknowledge.a <-- unified_body[0];")
                            appendLine("\t\tresult = knowledge.c;")
                        } else {
                            appendLine("\tresult = 1;")
                            rule.body.forEachIndexed { index, predicate ->
                                appendLine("\tknowledge[$knowledgeUsageCounter].a <-- unified_body[$index];")
                                appendLine("\tresult = result && knowledge[$knowledgeUsageCounter].c;")
                                knowledgeUsageCounter++
                            }
                        }
                    } else if(rule.body[0].name == "=") {
                        appendLine("\t\tresult = 1;")
                    } else {
                        appendLine("\t\tif ( ${constraints[ind]} ) {")
                        appendLine("\t\t\tresult = 1;")
                        appendLine("\t\t}")
                    }
                    append("\t}")
                    rule_prefix = " else "
                }

                // Empty Array check
                if(rule_clauses.any { it.head.hasArray() }){
                    val arrayPositions = rule_clauses.map { clause ->
                        clause.head.terms.mapIndexed { index, term ->
                            if(term is Predicate && term.name == "[]"){
                                index
                            } else {
                                -1
                            }
                        }.filter { it != -1 }
                    }
                    append("$rule_prefix if ( ")
                    var internalPrefix = ""
                    arrayPositions[0].forEach {
                        append("${internalPrefix}goal_args[${it+1}] == ${mapping["[]"]}")
                        internalPrefix = " && "
                    }
                    append(" && unified_body[0][0] == ${mapping["true"]}")
                    append(" ) {")
                    appendLine("\n\t\tresult = 1;")
                    append("\t}")


                }

                appendLine("\n\tc <-- result;")
                appendLine("\tc === 1;")
                appendLine("}")
            }
        )

    } // rules.forEach
    val mapping_code = buildString {
        clauses.groupBy { it.head.name }.forEach { (name, _) ->
            appendLine("\tvar ${name} = ${mapping[name]};")
        }
        appendLine("\tvar true = ${mapping["true"]};")
    }

    val rule_calls = buildString {
        rules.forEach { (name, rules) ->
            appendLine(
                "\tcomponent ${name}Goal = Goal${
                    name.replaceFirstChar {
                        if (it.isLowerCase()) it.titlecase(
                            Locale.getDefault()
                        ) else it.toString()
                    }
                }();"
            )
        }
        val knowledgeAble = knowledgeBase.groupBy { it.head.name }
        if (knowledgeAble.size == 1) {
            appendLine("\tcomponent knowledge = KnowledgeChecker();")
        } else if (knowledgeAble.size > 1) {
            appendLine("\tcomponent knowledge[${knowledgeAble.size}];")
            appendLine("\tfor (var i = 0; i < ${knowledgeAble.size}; i++) {")
            appendLine("\t\tknowledge[i] = KnowledgeChecker();")
            appendLine("\t}")
        }
        var knowledgeUsageCounter = 0
        var rule_prefix = "\t"
        rules.forEach { (name, rule_clauses) ->
            val maxUniBody = rule_clauses.maxOf { it.body.size }
            appendLine("${rule_prefix}if(goal_args[0] == ${name}) {")
            appendLine("\t\t${name}Goal.goal_args <-- goal_args;")
            for (i in 0..< maxUniBody) {
                appendLine("\t\t${name}Goal.unified_body[${i}] <-- unified_body[${i}];")
            }
            appendLine("\t\tresult = ${name}Goal.c;")
            append("\t}")
            rule_prefix = " else "
        }
        knowledgeAble.forEach { (name, rules) ->
            if (knowledgeAble.size == 1) {
                appendLine("${rule_prefix}if(goal_args[0] == ${name}) {")
                appendLine("\t\tknowledge.a <-- goal_args;")
                appendLine("\t\tresult = knowledge.c;")
                append("\t}")
            } else {

                appendLine("${rule_prefix}if(goal_args[0] == ${name}) {")
                appendLine("\t\tknowledge[$knowledgeUsageCounter].a <-- goal_args;")
                appendLine("\t\tresult = knowledge[$knowledgeUsageCounter].c;")
                knowledgeUsageCounter++

                append("\t}")

            }
            rule_prefix = " else "
        }
    }
    val branchingFactor = 13//rules.maxOf { it.value[0].body.size }


    val transition_constraints = buildString {
        clauses.groupBy { it.head.name }.forEach { (name, clauses) ->

            var prefix = ""
            val prevBodyChecks = buildString {
               clauses.forEach { clause ->
                   var innerPrefix = ""
                   append(prefix)
                   clause.body.forEachIndexed { index, predicate ->
                       append("${innerPrefix}prevUnifiedBodies[${index}][0] == ${
                           if (
                               Parser.SPECIAL_TERMS.any {
                                   predicate.name.contains(it)
                               }.not() &&
                               Parser.OPERATORS.any {
                                   predicate.name.contains(it)
                               }.not()
                           )
                               predicate.name else if (predicate.name == "=") mapping["true"] else mapping[predicate.name]
                       }")
                       innerPrefix = " && "
                   }
                   if(clause.body.isEmpty())
                       innerPrefix = ""
                   for (i in clause.body.size until branchingFactor) {
                       append("${innerPrefix}prevUnifiedBodies[${i}][0] == 0")
                       innerPrefix = " && "
                   }
                   prefix = " || "
               }
            }
            appendLine(
                "\tif(currentGoal[0] == $name) {\n"
                        + "\t\tif ( $prevBodyChecks ) {\n"
                        + "\t\t\tresult = 1;\n"
                        + "\t\t}\n"
                        + "\t}"
            )

        }
    }

    val maxDepth = 4;


    val template = File("template.circom").readText()

    // Padded knowledge base. Each element in the knowledge base shall have a uniform length
    // Specifically, the length of the element with the longest length
    val knowLedgeBasePadded = knowledgeBase.map { clause ->
        val padded = clause.head.encode(mapping).toMutableList()
        while (padded.size < maxPerdicateLength) {
            padded.add(0)
        }
        padded
    }

    val bucketSize : Int = bucketVariables.values.sum()


    val generatedCode = template
        .replace("REPLACE_RULE_TEMPLATES", generated_rule_code.toString())
        .replace("REPLACE_PREDICATE_MAPPINGS", mapping_code)
        .replace("REPLACE_RULE_CALLS", rule_calls)
        .replace("REPLACE_KNOWLEDGE_BASE_LEN", knowledgeBase.size.toString())
        .replace("REPLACE_KNOWLEDGE_BASE_ARRAY", knowLedgeBasePadded.joinToString(",") { it.toString() })
        .replace("REPLACE_TRANSITION_RULES", transition_constraints)
        .replace("REPLACE_MAX_DEPTH", maxDepth.toString())
        .replace("REPLACE_BRANCH_FACTOR", branchingFactor.toString())
        .replace("MAX_BODY_SIZE","$maxPerdicateLength")
        .replace("SUCH_EMPTY",IntArray(maxPerdicateLength).joinToString(","){"0"})
        .replace("MAX_BUCKET_SIZE", bucketSize.toString())
        .replace("MAX_BUCKET_ELEMENT_SIZE", maxBucketElementSize.toString())

    File("generated.circom").writeText(generatedCode)

    mapping.forEach { (name, index) ->
        println("'$name': $index,")
    }

    val treeJsonText = File("tree.json").readText()
    var tree = ResolutionTree.parseJson(treeJsonText,mapping)
    val maxUniBody = rules.maxOf { it.value.maxOf { it.body.size } }
    //println(tree.getMaxDepth())
    tree = tree.standardize(unificationCount_input = branchingFactor, max_elements = maxPerdicateLength);
    File("input_tree.json").writeText(tree.toBFSJson(bucketSize = bucketSize))
}

/**
 * List the Array type terms in the prolog program
 * @param rules The clauses of the prolog program in a map, where the key is the name of the predicate, and the value is a list of clauses
 * @return The names of the variables that are arrays
 */
fun findArrayPredicateVariables(rules: Map<String, List<Clause>>) : Map<String,Int> {
    // List the arrays (predicates that's name is [] ) and print them
    // We need to find them recursively, because they can be nested in other predicates
    // If we find an array, save the name of its parent predicate
    val arrays = mutableMapOf<String,Int>()
    fun findArrays(predicate: Predicate, parent: Predicate? = null) {
        if (predicate.name == "[]") {
            arrays[parent!!.terms[0].name ?: "root"] = predicate.terms.size
        } else {
            predicate.terms.forEach { term ->
                if (term is Predicate) {
                    findArrays(term, predicate)
                }
            }
        }
    }
    rules.forEach { (name, rules) ->
        rules.forEach { rule ->
            rule.body.forEach { predicate ->
                findArrays(predicate)
            }
        }
    }

    return arrays.toMap()
}

/**
 * Find the maximum size of the arrays in the prolog program
 * @param rules The clauses of the prolog program in a map, where the key is the name of the predicate, and the value is a list of clauses
 * @return The maximum size of the arrays
 */
fun findArrayTermMaxSize(rules: Map<String, List<Clause>>) : Int {
    // Find the maximum size of the arrays
    // We need to find them recursively, because they can be nested in other predicates
    // We first need to find the array predicate (predicate with name [])
    // Then we need to find the size of the array by recursively counting the number of elements in the array
    // Then we need to find the maximum size of the arrays


    val arraysSizes = mutableSetOf<Int>()

    fun findArraySize(predicate: Predicate) : Int {
        if (predicate.terms.isEmpty()) {
            return 1
        } else if(predicate.name == "[]") {

            return predicate.terms.size + 1
        } else {
            var size = 0
            predicate.terms.forEach { term ->
                if (term is Predicate) {
                    size += findArraySize(term)
                }
            }
            return size
        }
    }

    rules.forEach { (name, rules) ->
        rules.forEach { rule ->
            rule.body.forEach { predicate ->
                arraysSizes.add(findArraySize(predicate))
            }
        }
    }

    return arraysSizes.maxOrNull()!!
}


fun clauseGenerateArithmeticsCheck(clause: Clause): String {
    // Generate the code to check aritmetics in a clause
    val arithmeticPredicates = clause.body.filter { it.hasAritmetic() }
    val asserts = buildList {
        arithmeticPredicates.forEach{  predicate ->
            add(predicateToString(predicate, clause.body.indexOf(predicate)))
        }
    }.map { "\t\tassert($it);" }

    return buildString {
        asserts.forEach {
            appendLine(it)
        }
    }
}


fun predicateToString(predicate: Predicate,unificationIndex: Int,termIndexStart :Int = 0): String {
    // Helper function to handle the transformation
    fun termToString(term: Term): String = when {
        term.name.isInt() -> term.name
        term is Variable -> "unified_body[$unificationIndex][${predicate.terms.indexOf(term) + 1 + termIndexStart}]"
        term is Predicate -> predicateToString(term,unificationIndex,predicate.terms.filter { (it is Predicate).not() }.size+ termIndexStart)
        else -> throw IllegalArgumentException("Unsupported term type")
    }

    return when (predicate.name) {
        "is" -> "${termToString(predicate.terms[0])} == ${termToString(predicate.terms[1])}"
        "/" -> "(${termToString(predicate.terms[0])} - (${termToString(predicate.terms[0])} % ${termToString(predicate.terms[1])})) / ${termToString(predicate.terms[1])}" // Workaround for division
        else -> "${termToString(predicate.terms[0])}  ${predicate.name} ${termToString(predicate.terms[1])}"
    }
}

fun String.isInt(): Boolean {
    return this.toIntOrNull() != null
}
